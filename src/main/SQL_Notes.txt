select * from employees;

select * from user_tables;
SELECT * FROM USER_TABLES;
--KEYWORDS AND TABLES NAMES IS NOT CASE SENSETIVE
--VALUES ARE CASE SENSETIVE
--SQL        NOSQL
--ORACLE   -- MONGODB
--MYSQL     -- REDIS

--CRUD
--CREATE --
--READ -- SELECT
--UPDATE --
--DESTROY  --

 --SYNTAX
-- SELECT * -- READ EVERYTHING
-- SELECT <COLUMN-NAME OR * > FROM <TABLE-NAME>
SELECT FIRST_NAME FROM EMPLOYEES;
SELECT FIRST_NAME , LAST_NAME FROM EMPLOYEES;
SELECT   LAST_NAME , FIRST_NAME FROM EMPLOYEES;

--GET THE EMP_ID , FIRST_NAME , LAST_NAME , HIRE_DATE FROM EMPLOYEES TABLE
SELECT EMPLOYEE_ID ,FIRST_NAME , LAST_NAME , HIRE_DATE  FROM EMPLOYEES;
--
SELECT * FROM JOB_HISTORY;
SELECT * FROM COUNTRIES;

SELECT * FROM EMPLOYEES WHERE FIRST_NAME = 'David';

--WHERE CLAUSE IS THE FOR FILTERING specific data from table;
--SYNTAX
--SELECT <COLUMN_NAME> FROM <TABLE_NAME> WHERE = <CONDITIONS>;
SELECT * FROM EMPLOYEES WHERE LAST_NAME = 'Olson';
--find somebody from employees table who work as IT_prog
select * from employees where job_id = 'IT_PROG';

SELECT * FROM COUNTRIES;

--COUNTRY NAME WHERE REGION_ID IS 3

SELECT COUNTRY_NAME FROM COUNTRIES WHERE REGION_ID = 3;

--FIND EMPL WHO HAVE SALARY > 10000 DOLLARS
--DBA - DATABASE ADMIN

SELECT * FROM EMPLOYEES WHERE SALARY >= 10000 AND JOB_ID  = 'PU_MAN';
--BOTH CONDITIONS NEED TO BE TRUE
--AND -- OR

SELECT * FROM EMPLOYEES WHERE SALARY >= 10000 OR JOB_ID  = 'PU_MAN';
--OR -- ONE OF THE CONDITION NEED TO BE TRUE

--4 MAIN FUNCTIONAL CATEGORIES

        -- DML - DATA MANIPULATION LANGUAGE
        -- INSERT , UPDATE , DELETE DATA FROM TABLE

        --DQL -  DATA QUERY LANGUAGE
        --SELECT -- RETRIVE DATA FROM DATABASE

        --DDL - DATA DEFINITION LANGUAGE
        -- DEFINE A SCHEMA , TABLES AND RULES USED WHILE CREATING THE DB;

        -- DCL - DATA CONTROL LANGUAGE
        --USED FOR CONTROLING THE PERMITIONS , GIVING ACCESSES TO OTHER USERS

        SELECT * FROM EMPLOYEES WHERE HIRE_DATE BETWEEN '01-JAN-93' AND '31-DEC-96';

        -- BETWEEN IS GETTING DATA FROM 2 CONDITIONS USING AND KEYWORD

--FIND EMPL WHO HAVE SALARY BETWEEN 3100 AND 14000
SELECT * FROM EMPLOYEES WHERE SALARY BETWEEN 3100 AND 14000;
--FIND EMPL WHO HAVE EMPL_ID BETWEEN 100 AND 125
SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID >= 100 AND employee_id <= 120;
SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID BETWEEN 100 AND 120;

--IN
--FIND EMPL WHO HAVE SALARY ONLY 24000 OR 4800
SELECT * FROM EMPLOYEES WHERE SALARY = 24000 OR SALARY = 4800;
--FIND EMPLYOEES WHO HAVE EMPLOYEE ID 100 , 109, 129;
SELECT * FROM EMPLOYEES WHERE employee_id = 100 OR employee_id = 109 OR employee_id = 129;

SELECT FIRST_NAME , LAST_NAME FROM EMPLOYEES WHERE employee_id IN (100,109,129);

--FIND EMPL WHO HAVE SALARY ONLY 24000 OR 4800
SELECT * FROM EMPLOYEES WHERE SALARY IN (24000, 4800);

-- LIKE WHILECARD
-- START WITH

SELECT FIRST_NAME , LAST_NAME FROM EMPLOYEES WHERE FIRST_NAME LIKE 'A%' OR FIRST_NAME LIKE 'B%';

--CONTAINS a somewhere it the first name
SELECT FIRST_NAME , LAST_NAME FROM EMPLOYEES WHERE FIRST_NAME LIKE '%a%';

--END WITH a
SELECT FIRST_NAME , LAST_NAME FROM EMPLOYEES WHERE FIRST_NAME LIKE '%a';

--second letter is 'l'
SELECT FIRST_NAME , LAST_NAME FROM EMPLOYEES WHERE FIRST_NAME LIKE '_l%';

--find employees * who start a job in JUN
select * from employees where hire_date like '%JUN%';
select * from employees where hire_date like '__-JUN-__';
--find empl who have firstName start with A and last_name contains b
select * from employees where first_name like 'A%' and last_name like '%b%';

select * from employees where first_name like '_A%';

--UPPER
SELECT UPPER(FIRST_NAME) FROM EMPLOYEES ;

--LOWER
SELECT LOWER(EMAIL) FROM EMPLOYEES;

--INITCAP -INITAL CAPITAL FIRST LETTER TO UPPERCASE
SELECT FIRST_NAME , LAST_NAME , INITCAP(EMAIL) FROM EMPLOYEES;

--ALIES -- NICK NAME - GIVE NICK NAME TO OUTPUT COLUMN

SELECT FIRST_NAME , LAST_NAME , INITCAP(EMAIL) AS EMIAL FROM EMPLOYEES;

--SUBSTR - SAME AS IN JAVA
SELECT SUBSTR(FIRST_NAME ,0, 5) AS FIRST_NAME FROM EMPLOYEES;


--CONCATINATION

SELECT FIRST_NAME , LAST_NAME , lower(EMAIL) ||'@gmail.com' as fullname from employees;


SELECT FIRST_NAME || '_' ||last_name as fullname from employees;

--find empl first_name , last_name , salary who have salary more than 15k

select first_name , last_name , salary from employees where salary >= 15000;


--class 2 3/20/24

-- firstname lastname empl who who at departmement_id = 50;

--FIrst name , last name , salary empl who wokr in department 50 and salary  > 5000;

select first_name , last_name from employees where department_id = 50;

select * from departments;

select first_name , last_name , salary from employees where department_id = 50 and salary >5000;

--find empl who work at department 50 and empl at department 60

select first_name , last_name , department_id from employees where department_id = 50 or department_id = 60;

--find empl who have first_name starts with A
select * from employees where first_name like 'A%';
--get empl first and last name and email as lower case and name the result-set column as email
select first_name , last_name , lower(email) as email from employees;
--get the empl first name and concat the upper case lastName ;
select concat(first_name , upper(last_name)) from employees;
select first_name || ' ' ||upper(last_name) from employees;

--get the email as initcap concat first 3 letters from LastName and concat @gmail.com
select initcap(email) || substr(last_name , 1, 3) || '@gmail.com' from employees;
--get the all empl infor and where emplId is not 100 105 and 102
select * from employees where employee_id not in (100, 105, 102 ) ;

--find empl where 2nd letter of last name is  b
select * from employees where last_name like '_a%';
--find empl infor who have lst name length only 5
select * from employees where Length(last_name) = 5;

--Sorting -- Order by

select * from employees order by first_name asc;
select * from employees order by first_name desc;

select * from employees order by first_name asc , last_name asc;
--sorting is going to have by first column (duplicates) , second column

--first name , last ,salary then order it by salary
select * from employees order by salary;

--find people who make more than 5000 adn order by asc salary
select * from employees where salary > 5000 order by salary;
--find first_name , last_name , salary , depratment_id  where salary is more than 10000 and deparmtnes is
--not 50 order by
--first_name ;

select first_name , last_name ,
salary , department_id
from employees
where salary > 10000
and  not department_id = 50;


--find people with commission_pct;
--is not
select * from employees where commission_pct is not null;
select * from departments;


--uniqe values --distinct

select distinct first_name from employees order by first_name;

select distinct department_id , first_name from employees  order by first_name;
select distinct job_id , department_id from employees;


select country_id from locations;
select * from locations;

select * from countries;


---Round , Trunc , MOD
select salary + 0.9 from employees;
select round(salary + 0.9) from employees;
select round(salary + 0.5) from employees;

select trunc(salary + 0.9)  from employees;

select first_name , last_name  ,  salary , mod(salary, 5000) from employees order by salary;
select first_name , last_name  ,  salary  from employees order by salary;

--Multiple row functions aka Aggregate functions
--count, min  , max , sum ,AVG

select count(*) from employees;
select count(country_name ) from countries;

select avg(salary) from employees; -- only works with numeric values;

select sum(salary ) from employees; --only works with numeric values

select max(salary) from employees;

select min(salary) from employees;

select min(first_name) from employees;

select max(salary), first_name from employees;

--group by clause

--get the avg salary and round it ;
--get the avg salary and trunc it ;

select round(avg(salary)) from employees;
select trunc(avg(salary)) from employees;

select avg(round(salary)) from employees;

select * from employees;

select department_id , round(avg(salary)) from employees having salary > 5000 group by department_id;

select first_name from employees group by first_name order by first_name;

select department_id , round(avg(salary)) from employees group by department_id  having round(avg(salary)) > 5000;

--count the numb of employees in each job_id category
select job_id , count(*) as numb_of_employees from employees group by job_id;

--how much salary company spend a year;
select sum(salary)*12 from employees;
select sum(salary) from employees;

-- find the total salary exp for each depratment
select department_id , sum(salary) from employees group by department_id;

-- find the avg salary exp for each depratment where salary greater than 5000;
select department_id , trunc(avg(salary)) from employees group by department_id having trunc(avg(salary)) > 5000;

select job_id , count(*) as num_of_empl
from employees
group by job_id
having count(*) > 10;

-- find departments with total salaries exceeding 100 000
select department_id , sum (salary)
from employees
group by department_id
having sum(salary ) > 100000;


-- subqery -- nested query
select * from employees where first_name  = (select first_name from employees where first_name = 'Alexander');

select * from employees order by salary desc;

select first_name from employees where salary = (select max(salary) from employees);

select first_name from employees where salary = 24000;

select first_name
from employees
where salary = (select max(salary)
from employees where salary != (select max(salary) from employees));



--rownum
select first_name , salary from employees where rownum <= 2 order by salary ;
--LIMIT

select * from departments;

--empl first last name department_id where department name Sales;

select first_name , last_name , department_id
from employees
where department_id = (select
department_id
from departments
where department_name = 'Sales');

--ORder of the keywords
--Select
--from
--where
--group by
--having
--order by







